{
  "address": "0x8C9ee6510a2d3C829f43b3d7f298b076B513f23F",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "poolId",
          "type": "address"
        },
        {
          "internalType": "int24[]",
          "name": "tickRange",
          "type": "int24[]"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "tokenAddress",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "price",
              "type": "uint256"
            }
          ],
          "internalType": "struct IProportionFacet.PoolTokenPrices[]",
          "name": "prices",
          "type": "tuple[]"
        }
      ],
      "name": "getProportionForRebalance",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address[]",
              "name": "inputTokenAddresses",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "inputTokenAmounts",
              "type": "uint256[]"
            },
            {
              "internalType": "address[]",
              "name": "outputTokenAddresses",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "outputTokenProportions",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256[]",
              "name": "outputTokenAmounts",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256[]",
              "name": "poolProportionsUsd",
              "type": "uint256[]"
            }
          ],
          "internalType": "struct IProportionFacet.ResultOfProportion",
          "name": "result",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pair",
          "type": "address"
        },
        {
          "internalType": "int24[]",
          "name": "tickRange",
          "type": "int24[]"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "tokenAddress",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "price",
              "type": "uint256"
            }
          ],
          "internalType": "struct IProportionFacet.InputSwapToken[]",
          "name": "inputTokens",
          "type": "tuple[]"
        }
      ],
      "name": "getProportionForZap",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address[]",
              "name": "inputTokenAddresses",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "inputTokenAmounts",
              "type": "uint256[]"
            },
            {
              "internalType": "address[]",
              "name": "outputTokenAddresses",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "outputTokenProportions",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256[]",
              "name": "outputTokenAmounts",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256[]",
              "name": "poolProportionsUsd",
              "type": "uint256[]"
            }
          ],
          "internalType": "struct IProportionFacet.ResultOfProportion",
          "name": "result",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xc21cf17d4690d2604750d14e843c79a557dbc8ab2343e86a46d7fc652ac052c1",
  "receipt": {
    "to": null,
    "from": "0xab918d486c61ADd7c577F1af938117bBD422f088",
    "contractAddress": "0x8C9ee6510a2d3C829f43b3d7f298b076B513f23F",
    "transactionIndex": 17,
    "gasUsed": "2757814",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x8f182bd2018b387b7c0f54d0aa9fc838b24e2ef37e6f060b61ad271ed15dd503",
    "transactionHash": "0xc21cf17d4690d2604750d14e843c79a557dbc8ab2343e86a46d7fc652ac052c1",
    "logs": [],
    "blockNumber": 240553925,
    "cumulativeGasUsed": "5756596",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 3,
  "solcInputHash": "cca7494c9b14128c4f4c13e56c203ac7",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"poolId\",\"type\":\"address\"},{\"internalType\":\"int24[]\",\"name\":\"tickRange\",\"type\":\"int24[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"internalType\":\"struct IProportionFacet.PoolTokenPrices[]\",\"name\":\"prices\",\"type\":\"tuple[]\"}],\"name\":\"getProportionForRebalance\",\"outputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"inputTokenAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"inputTokenAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"outputTokenAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"outputTokenProportions\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"outputTokenAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"poolProportionsUsd\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IProportionFacet.ResultOfProportion\",\"name\":\"result\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"int24[]\",\"name\":\"tickRange\",\"type\":\"int24[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"internalType\":\"struct IProportionFacet.InputSwapToken[]\",\"name\":\"inputTokens\",\"type\":\"tuple[]\"}],\"name\":\"getProportionForZap\",\"outputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"inputTokenAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"inputTokenAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"outputTokenAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"outputTokenProportions\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"outputTokenAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"poolProportionsUsd\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IProportionFacet.ResultOfProportion\",\"name\":\"result\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/facets/core/ProportionFacet.sol\":\"ProportionFacet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x3088eb2868e8d13d89d16670b5f8612c4ab9ff8956272837d8e90106c59c14a0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0x9f4357008a8f7d8c8bf5d48902e789637538d8c016be5766610901b4bba81514\",\"license\":\"MIT\"},\"@overnight-contracts/common/contracts/libraries/OvnMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nlibrary OvnMath {\\n\\n    uint256 constant BASIS_DENOMINATOR = 10 ** 4;\\n\\n    function abs(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return (x > y) ? (x - y) : (y - x);\\n    }\\n\\n    function addBasisPoints(uint256 amount, uint256 basisPoints) internal pure returns (uint256) {\\n        return amount * (BASIS_DENOMINATOR + basisPoints) / BASIS_DENOMINATOR;\\n    }\\n\\n    function reverseAddBasisPoints(uint256 amount, uint256 basisPoints) internal pure returns (uint256) {\\n        return amount * BASIS_DENOMINATOR / (BASIS_DENOMINATOR + basisPoints);\\n    }\\n\\n    function subBasisPoints(uint256 amount, uint256 basisPoints) internal pure returns (uint256) {\\n        return amount * (BASIS_DENOMINATOR - basisPoints) / BASIS_DENOMINATOR;\\n    }\\n\\n    function reverseSubBasisPoints(uint256 amount, uint256 basisPoints) internal pure returns (uint256) {\\n        return amount * BASIS_DENOMINATOR / (BASIS_DENOMINATOR - basisPoints);\\n    }\\n}\\n\",\"keccak256\":\"0xb72198ec96f2754e9bf20531b1b8744f06ff2cc1c720e0ecc07196087cbe9657\",\"license\":\"MIT\"},\"contracts/facets/core/ProportionFacet.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport \\\"../../interfaces/IMasterFacet.sol\\\";\\nimport \\\"../../interfaces/Constants.sol\\\";\\n\\ncontract ProportionFacet is IProportionFacet {\\n    function getProportionForZap(\\n        address pair,\\n        int24[] memory tickRange,\\n        InputSwapToken[] memory inputTokens\\n    ) external view returns (ResultOfProportion memory result) {\\n        IMasterFacet master = IMasterFacet(address(this));\\n        uint8[] memory decimals = new uint8[](inputTokens.length);\\n        OutTokenInfo[] memory outTokens = new OutTokenInfo[](2);\\n        uint256 sumInputsUsd;\\n\\n        outTokens[0].idx = inputTokens.length;\\n        outTokens[1].idx = inputTokens.length;\\n        (outTokens[0].token, outTokens[1].token) = master.getPoolTokens(pair);\\n\\n        result.inputTokenAddresses = new address[](inputTokens.length);\\n        result.inputTokenAmounts = new uint256[](inputTokens.length);\\n        result.outputTokenAddresses = new address[](2);\\n        result.outputTokenProportions = new uint256[](2);\\n        result.outputTokenAmounts = new uint256[](2);\\n        result.poolProportionsUsd = new uint256[](2);\\n\\n        for (uint256 i = 0; i < inputTokens.length; i++) {\\n            decimals[i] = IERC20Metadata(inputTokens[i].tokenAddress).decimals();\\n            uint256 amountUsd = master.mulDiv(inputTokens[i].price, inputTokens[i].amount, 10 ** decimals[i]);\\n            sumInputsUsd += amountUsd;\\n            if (inputTokens[i].tokenAddress == outTokens[0].token) {\\n                outTokens[0].idx = i;\\n                outTokens[0].amountUsd = amountUsd;\\n                continue;\\n            }\\n            if (inputTokens[i].tokenAddress == outTokens[1].token) {\\n                outTokens[1].idx = i;\\n                outTokens[1].amountUsd = amountUsd;\\n                continue;\\n            }\\n            // front (!)\\n            result.inputTokenAddresses[i] = inputTokens[i].tokenAddress;\\n            result.inputTokenAmounts[i] = inputTokens[i].amount;\\n        }\\n\\n        (outTokens[0].propAmount, outTokens[1].propAmount) = getProportion(pair, tickRange);\\n        outTokens[0].prop = outTokens[0].propAmount * master.getCurrentPrice(pair);\\n        outTokens[1].prop = outTokens[0].prop + outTokens[1].propAmount * (10 ** IERC20Metadata(outTokens[1].token).decimals());\\n        result.poolProportionsUsd[0] = master.mulDiv(sumInputsUsd, outTokens[0].prop, outTokens[1].prop);\\n        result.poolProportionsUsd[1] = sumInputsUsd - result.poolProportionsUsd[0];\\n\\n        if (result.poolProportionsUsd[0] == outTokens[0].amountUsd && result.poolProportionsUsd[1] == outTokens[1].amountUsd &&\\n            (outTokens[0].prop == 0 || outTokens[0].prop == outTokens[1].prop)) {\\n            delete result.inputTokenAddresses;\\n            delete result.inputTokenAmounts;\\n            result.outputTokenAmounts[0] = outTokens[0].idx < inputTokens.length ? inputTokens[outTokens[0].idx].amount : 0;\\n            result.outputTokenAmounts[1] = outTokens[1].idx < inputTokens.length ? inputTokens[outTokens[1].idx].amount : 0;\\n            return result;\\n        }\\n\\n        for (uint256 i = 0; i < 2; i++) {\\n            if (outTokens[i].idx < inputTokens.length && result.poolProportionsUsd[i] < outTokens[i].amountUsd) {\\n                outTokens[i].amountToSwap = master.mulDiv(outTokens[i].amountUsd - result.poolProportionsUsd[i], 10 ** decimals[outTokens[i].idx], inputTokens[outTokens[i].idx].price);\\n                result.inputTokenAddresses[outTokens[i].idx] = inputTokens[outTokens[i].idx].tokenAddress;\\n                result.inputTokenAmounts[outTokens[i].idx] = outTokens[i].amountToSwap;\\n                result.outputTokenAddresses[0] = outTokens[1 - i].token;\\n                // front (!)\\n                result.outputTokenProportions[0] = BASE_DIV;\\n                result.outputTokenAmounts[i] = inputTokens[outTokens[i].idx].amount - outTokens[i].amountToSwap;\\n                result.outputTokenAmounts[1 - i] = outTokens[1 - i].idx < inputTokens.length ? inputTokens[outTokens[1 - i].idx].amount : 0;\\n                return result;\\n            }\\n        }\\n\\n        result.outputTokenAddresses[0] = outTokens[0].token;\\n        result.outputTokenAddresses[1] = outTokens[1].token;\\n        result.outputTokenProportions[0] = master.mulDiv(result.poolProportionsUsd[0] - outTokens[0].amountUsd, BASE_DIV,\\n            (result.poolProportionsUsd[0] + result.poolProportionsUsd[1]) - (outTokens[0].amountUsd + outTokens[1].amountUsd));\\n        result.outputTokenProportions[1] = BASE_DIV - result.outputTokenProportions[0];\\n        result.outputTokenAmounts[0] = outTokens[0].idx < inputTokens.length ? inputTokens[outTokens[0].idx].amount : 0;\\n        result.outputTokenAmounts[1] = outTokens[1].idx < inputTokens.length ? inputTokens[outTokens[1].idx].amount : 0;\\n        return result;\\n    }\\n\\n    function getProportionForRebalance(\\n        uint256 tokenId,\\n        address poolId,\\n        int24[] memory tickRange,\\n        PoolTokenPrices[] memory prices\\n    ) external view returns (ResultOfProportion memory result) {\\n        require(prices.length == 2, \\\"!= 2 tokens\\\");\\n        IMasterFacet master = IMasterFacet(address(this));\\n        uint8[] memory decimals = new uint8[](2);\\n        OutTokenInfo[] memory outTokens = new OutTokenInfo[](2);\\n        uint256 sumInputsUsd;\\n\\n        (outTokens[0].token, outTokens[1].token) = master.getPoolTokens(poolId);\\n        require(\\n            outTokens[0].token == prices[0].tokenAddress && outTokens[1].token == prices[1].tokenAddress,\\n            \\\"Invalid input tokens\\\"\\n        );\\n        result.inputTokenAddresses = new address[](1);\\n        result.inputTokenAmounts = new uint256[](1);\\n        result.outputTokenAddresses = new address[](1);\\n        result.outputTokenProportions = new uint256[](1);\\n        result.outputTokenAmounts = new uint256[](2);\\n        result.poolProportionsUsd = new uint256[](2);\\n\\n        (outTokens[0].amount, outTokens[1].amount) = master.getPositionAmounts(tokenId);\\n        for (uint256 i = 0; i < 2; i++) {\\n            decimals[i] = IERC20Metadata(prices[i].tokenAddress).decimals();\\n            uint256 amountUsd = master.mulDiv(prices[i].price, outTokens[i].amount, 10 ** decimals[i]);\\n            sumInputsUsd += amountUsd;\\n            outTokens[i].amountUsd = amountUsd;\\n        }\\n\\n        (outTokens[0].propAmount, outTokens[1].propAmount) = getProportion(poolId, tickRange);\\n        outTokens[0].prop = outTokens[0].propAmount * master.getCurrentPrice(poolId);\\n        outTokens[1].prop = outTokens[0].prop + outTokens[1].propAmount * (10 ** decimals[1]);\\n        result.poolProportionsUsd[0] = master.mulDiv(sumInputsUsd, outTokens[0].prop, outTokens[1].prop);\\n        result.poolProportionsUsd[1] = sumInputsUsd - result.poolProportionsUsd[0];\\n\\n        for (uint256 i = 0; i < 2; i++) {\\n            if (result.poolProportionsUsd[i] < outTokens[i].amountUsd) {\\n                outTokens[i].amountToSwap = master.mulDiv(outTokens[i].amountUsd - result.poolProportionsUsd[i], 10 ** decimals[i], prices[i].price);\\n                result.inputTokenAddresses[0] = prices[i].tokenAddress;\\n                result.inputTokenAmounts[0] = outTokens[i].amountToSwap;\\n                result.outputTokenAddresses[0] = outTokens[1 - i].token;\\n                // front (!)\\n                result.outputTokenProportions[0] = BASE_DIV;\\n                result.outputTokenAmounts[i] = outTokens[i].amount - outTokens[i].amountToSwap;\\n                result.outputTokenAmounts[1 - i] = outTokens[1 - i].amount;\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    function getProportion(\\n        address pair,\\n        int24[] memory tickRange\\n    ) internal view returns (uint256 token0Amount, uint256 token1Amount) {\\n        IMasterFacet master = IMasterFacet(address(this));\\n        (uint256 decimals0, uint256 decimals1) = master.getPoolDecimals(pair);\\n        uint256 dec0 = 10 ** decimals0;\\n        uint256 dec1 = 10 ** decimals1;\\n        uint160 sqrtRatioX96 = master.getPoolSqrtRatioX96(pair);\\n\\n        uint160 sqrtRatio0 = master.getSqrtRatioAtTick(tickRange[0]);\\n        uint160 sqrtRatio1 = master.getSqrtRatioAtTick(tickRange[1]);\\n        uint128 liquidity = master.getLiquidityForAmounts(sqrtRatioX96, sqrtRatio0, sqrtRatio1, dec0 * 1000, dec1 * 1000);\\n        (token0Amount, token1Amount) = master.getAmountsForLiquidity(sqrtRatioX96, sqrtRatio0, sqrtRatio1, liquidity);\\n        uint256 denominator = dec0 > dec1 ? dec0 : dec1;\\n\\n        token0Amount = token0Amount * (denominator / dec0);\\n        token1Amount = token1Amount * (denominator / dec1);\\n    }\\n}\\n\",\"keccak256\":\"0xb10615afec76d69fe199f0c92e488d2c7b9d57414837c2112b34ebb25aa6aeaf\",\"license\":\"MIT\"},\"contracts/interfaces/Constants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nbytes32 constant DEFAULT_ADMIN_ROLE = 0x00;\\nbytes32 constant UNIT_ROLE = keccak256(\\\"UNIT_ROLE\\\");\\nbytes32 constant PORTFOLIO_AGENT_ROLE = keccak256(\\\"PORTFOLIO_AGENT_ROLE\\\");\\nuint256 constant MAX_UINT_VALUE = type(uint256).max;\\nuint256 constant BASE_DIV = 1000000;\\n\",\"keccak256\":\"0x51c2ca02138926197eb5469947d07d2adf6821e08e5248b906c6edc3c04fb4a8\",\"license\":\"MIT\"},\"contracts/interfaces/IMasterFacet.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport \\\"./core/IPoolMathFacet.sol\\\";\\nimport \\\"./core/IPositionManagerFacet.sol\\\";\\nimport \\\"./core/IZapFacet.sol\\\";\\nimport \\\"./core/IMathFacet.sol\\\";\\nimport \\\"./core/IProportionFacet.sol\\\";\\nimport \\\"./Modifiers.sol\\\";\\nimport \\\"../libraries/core/LibCoreStorage.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@overnight-contracts/common/contracts/libraries/OvnMath.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\ninterface IMasterFacet is IPoolMathFacet, IPositionManagerFacet, IZapFacet, IMathFacet, IProportionFacet {}\\n\",\"keccak256\":\"0x775cfc10d6253a6a573fba125d9a7e3203754a8a3a873c6fec983e3d9c71bf64\",\"license\":\"MIT\"},\"contracts/interfaces/Modifiers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {LibAccessControl} from \\\"../libraries/core/LibAccessControl.sol\\\";\\nimport {LibCoreStorage} from \\\"../libraries/core/LibCoreStorage.sol\\\";\\nimport \\\"./Constants.sol\\\";\\n\\ncontract Modifiers {\\n    modifier onlyRole(bytes32 role) {\\n        LibAccessControl.checkRole(role);\\n        _;\\n    }\\n\\n    modifier onlyDiamond() {\\n        require(LibCoreStorage.coreStorage().diamond == msg.sender, \\\"Restricted to Diamond\\\");\\n        _;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(LibAccessControl.hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Restricted to Admin\\\");\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x42e6fcfce02e6b642f34275da1dfc6e0538c43484e0054eee9ad23dc941c261d\",\"license\":\"MIT\"},\"contracts/interfaces/core/IMathFacet.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface IMathFacet {\\n    function getCurrentPrice(address pair) external view returns (uint256);\\n\\n    function getTickSpacing(address pair) external view returns (int24);\\n\\n    function tickToPrice(address pair, int24 tick) external view returns (uint256);\\n\\n    function priceToClosestTick(address pair, uint256[] memory prices) external view returns (int24[] memory);\\n\\n    function getCurrentPoolTick(address pair) external view returns (int24 tick);\\n\\n    function closestTicksForCurrentTick(address pair) external view returns (int24 left, int24 right);\\n}\\n\",\"keccak256\":\"0x5a75edd0a8cbf7c3b2c7e05084f5469eb9e10906d6e63327a5e4d92dad2f72bb\",\"license\":\"MIT\"},\"contracts/interfaces/core/IPoolMathFacet.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface IPoolMathFacet {\\n    function toUint160(uint256 y) external view returns (uint160);\\n\\n    function mulDiv(uint256 a, uint256 b, uint256 denominator) external view returns (uint256);\\n\\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) external view returns (int24);\\n\\n    function getSqrtRatioAtTick(int24 tick) external view returns (uint160);\\n\\n    function getPoolDecimals(address pair) external view returns (uint256, uint256);\\n\\n    function getPoolSqrtRatioX96(address pair) external view returns (uint160);\\n\\n    function getPoolTickSpacing(address pair) external view returns (int24);\\n\\n    function getPoolTick(address pair) external view returns (int24);\\n\\n    function getPoolTokens(address pair) external view returns (address, address);\\n\\n    function getLiquidityForAmounts(\\n        uint160 sqrtRatioX96,\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint256 amount0,\\n        uint256 amount1\\n    ) external view returns (uint128);\\n\\n    function getAmountsForLiquidity(\\n        uint160 sqrtRatioX96,\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint128 liquidity\\n    ) external view returns (uint256, uint256);\\n}\\n\",\"keccak256\":\"0xe11314e0c1d656150fad39805414e3a96281859f1ae172aee68827da778e221c\",\"license\":\"MIT\"},\"contracts/interfaces/core/IPositionManagerFacet.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface IPositionManagerFacet {\\n    event CollectRewards(uint256 amount0, uint256 amount1);\\n\\n    struct PositionInfo {\\n        string platform;\\n        uint256 tokenId;\\n        address poolId;\\n        address token0;\\n        address token1;\\n        uint256 amount0;\\n        uint256 amount1;\\n        uint256 fee0;\\n        uint256 fee1;\\n        uint256 emissions;\\n        int24 tickLower;\\n        int24 tickUpper;\\n        int24 currentTick;\\n        bool isStaked;\\n    }\\n\\n    function mintPosition(\\n        address pair,\\n        int24 tickRange0,\\n        int24 tickRange1,\\n        uint256 amountOut0,\\n        uint256 amountOut1,\\n        address recipient\\n    ) external returns (uint256);\\n\\n    function increaseLiquidity(\\n        uint256 tokenId,\\n        uint256 amount0,\\n        uint256 amount1\\n    ) external returns (uint128);\\n\\n    function closePosition(uint256 tokenId, address recipient, address feeRecipient) external;\\n\\n    function getPositions(address wallet) external view returns (PositionInfo[] memory);\\n\\n    function getPositionAmounts(uint256 tokenId) external view returns (uint256, uint256);\\n\\n    function checkForOwner(uint256 tokenId, address sender) external view;\\n\\n    function getTokens(uint256 tokenId) external view returns (address, address);\\n\\n    function getTicks(uint256 tokenId) external view returns (int24, int24);\\n\\n    function getPool(uint256 tokenId) external view returns (address);\\n}\\n\",\"keccak256\":\"0x1d3c4c9f7f3cec4dfa026e505cac9231cb4c556dbe64e655f473cdaa51209d27\",\"license\":\"MIT\"},\"contracts/interfaces/core/IProportionFacet.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface IProportionFacet {\\n    struct InputSwapToken {\\n        address tokenAddress;\\n        uint256 amount;\\n        uint256 price;\\n    }\\n\\n    struct PoolTokenPrices {\\n        address tokenAddress;\\n        uint256 price;\\n    }\\n\\n    struct ResultOfProportion {\\n        address[] inputTokenAddresses;\\n        uint256[] inputTokenAmounts;\\n        address[] outputTokenAddresses;\\n        uint256[] outputTokenProportions;\\n        uint256[] outputTokenAmounts;\\n        uint256[] poolProportionsUsd;\\n    }\\n\\n    struct OutTokenInfo {\\n        uint256 idx;\\n        uint256 amount;\\n        uint256 amountUsd;\\n        uint256 prop;\\n        uint256 propAmount;\\n        uint256 amountToSwap;\\n        uint256 outAmount;\\n        address token;\\n    }\\n\\n    function getProportionForZap(\\n        address pair,\\n        int24[] memory tickRange,\\n        InputSwapToken[] memory inputTokens\\n    ) external view returns (ResultOfProportion memory);\\n\\n    function getProportionForRebalance(\\n        uint256 tokenId,\\n        address poolId,\\n        int24[] memory tickRange,\\n        PoolTokenPrices[] memory prices\\n    ) external view returns (ResultOfProportion memory);\\n}\\n\",\"keccak256\":\"0xc32819467ba5bc7723cae06eb4f4235fe2fc39941d29dfe856db7f9d96e92ab2\",\"license\":\"MIT\"},\"contracts/interfaces/core/IZapFacet.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface IZapFacet {\\n    struct ZapInParams {\\n        address pair;\\n        int24[] tickRange;\\n        uint256[] amountsOut;\\n    }\\n\\n    struct OutputToken {\\n        address tokenAddress;\\n        address receiver;\\n    }\\n\\n    struct InputToken {\\n        address tokenAddress;\\n        uint256 amountIn;\\n    }\\n\\n    struct SwapData {\\n        InputToken[] inputs;\\n        OutputToken[] outputs;\\n        bytes data;\\n    }\\n\\n    struct ResultOfLiquidity {\\n        uint amountAsset0Before;\\n        uint amountAsset1Before;\\n\\n        uint amountAsset0After;\\n        uint amountAsset1After;\\n\\n        uint[] amountsPut;\\n        uint[] amountsReturned;\\n    }\\n\\n    function zapIn(SwapData memory swapData, ZapInParams memory paramsData) external;\\n\\n    function zapOut(uint256 tokenId) external;\\n\\n    function rebalance(SwapData memory swapData, ZapInParams memory paramsData, uint256 tokenId) external;\\n\\n    function increase(SwapData memory swapData, ZapInParams memory paramsData, uint256 tokenId) external;\\n\\n    function merge(uint256 tokenIn, uint256[] memory tokensOut) external;\\n}\\n\",\"keccak256\":\"0xac76da852b82faf8e5dba4d461de15e9764664507507aee2c88d7ddeb3b7e303\",\"license\":\"MIT\"},\"contracts/libraries/core/LibAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport {Strings} from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\nlibrary LibAccessControl {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    bytes32 constant ACCESS_CONTROL_STORAGE_SLOT = keccak256(\\\"access.control.storage\\\");\\n\\n    struct RoleData {\\n        EnumerableSet.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    struct Layout {\\n        mapping(bytes32 => RoleData) roles;\\n    }\\n\\n    event RoleAdminChanged(\\n        bytes32 indexed role,\\n        bytes32 indexed previousAdminRole,\\n        bytes32 indexed newAdminRole\\n    );\\n\\n    event RoleGranted(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n\\n    event RoleRevoked(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n\\n\\n    function accessControlStorage() internal pure returns (Layout storage l) {\\n        bytes32 slot = ACCESS_CONTROL_STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n\\n    modifier onlyRole(bytes32 role) {\\n        checkRole(role);\\n        _;\\n    }\\n\\n\\n    /*\\n     * @notice query whether role is assigned to account\\n     * @param role role to query\\n     * @param account account to query\\n     * @return whether role is assigned to account\\n     */\\n    function hasRole(\\n        bytes32 role,\\n        address account\\n    ) internal view returns (bool) {\\n        return accessControlStorage().roles[role].members.contains(account);\\n    }\\n\\n    /**\\n     * @notice revert if sender does not have given role\\n     * @param role role to query\\n     */\\n    function checkRole(bytes32 role) internal view {\\n        checkRole(role, msg.sender);\\n    }\\n\\n    /**\\n     * @notice revert if given account does not have given role\\n     * @param role role to query\\n     * @param account to query\\n     */\\n    function checkRole(bytes32 role, address account) internal view {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(account),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /*\\n     * @notice query admin role for given role\\n     * @param role role to query\\n     * @return admin role\\n     */\\n    function getRoleAdmin(bytes32 role) internal view returns (bytes32) {\\n        return accessControlStorage().roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @notice set role as admin role\\n     * @param role role to set\\n     * @param adminRole admin role to set\\n     */\\n    function setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        accessControlStorage().roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /*\\n     * @notice assign role to given account\\n     * @param role role to assign\\n     * @param account recipient of role assignment\\n     */\\n    function grantRole(bytes32 role, address account) internal {\\n        accessControlStorage().roles[role].members.add(account);\\n        emit RoleGranted(role, account, msg.sender);\\n    }\\n\\n    /*\\n     * @notice unassign role from given account\\n     * @param role role to unassign\\n     * @parm account\\n     */\\n    function revokeRole(bytes32 role, address account) internal {\\n        accessControlStorage().roles[role].members.remove(account);\\n        emit RoleRevoked(role, account, msg.sender);\\n    }\\n\\n    /**\\n     * @notice relinquish role\\n     * @param role role to relinquish\\n     */\\n    function renounceRole(bytes32 role) internal {\\n        revokeRole(role, msg.sender);\\n    }\\n\\n\\n}\\n\",\"keccak256\":\"0x751a6e0e4acfc3878f6cff6716b786881a5fde23e1262b7591081070a627e16c\",\"license\":\"MIT\"},\"contracts/libraries/core/LibCoreStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary LibCoreStorage {\\n    bytes32 internal constant CORE_STORAGE_POSITION = keccak256(\\\"core.storage\\\");\\n\\n    struct CoreStorage {\\n        address odosRouter;\\n        address npm;\\n        uint256 stakeSlippageBP;\\n        address diamond;\\n    }\\n\\n    function coreStorage() internal pure returns (CoreStorage storage ds) {\\n        bytes32 position = CORE_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x25a26795568f7a50aed18b949ef764828e674758e1037bf3d2175750a23457f9\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\\n\",\"keccak256\":\"0x7434453e6d3b7d0e5d0eb7846ffdbc27f0ccf3b163591263739b628074dc103a\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50612b9e806100206000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80638866c09f1461003b578063b298ad6e14610064575b600080fd5b61004e6100493660046125a3565b610077565b60405161005b9190612717565b60405180910390f35b61004e6100723660046127cf565b611430565b61007f6123d9565b815130906000906001600160401b0381111561009d5761009d612475565b6040519080825280602002602001820160405280156100c6578160200160208202803683370190505b506040805160028082526060820190925291925060009190816020015b6100eb61240f565b8152602001906001900390816100e35790505090506000855182600081518110610117576101176128cf565b6020026020010151600001818152505085518260018151811061013c5761013c6128cf565b60209081029190910101515260405163ca4f280360e01b81526001600160a01b0385169063ca4f280390610174908b906004016128e5565b6040805180830381865afa158015610190573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101b491906128f9565b836000815181106101c7576101c76128cf565b602002602001015160e001846001815181106101e5576101e56128cf565b60209081029190910101516001600160a01b0392831660e0909101529116905285516001600160401b0381111561021e5761021e612475565b604051908082528060200260200182016040528015610247578160200160208202803683370190505b50855285516001600160401b0381111561026357610263612475565b60405190808252806020026020018201604052801561028c578160200160208202803683370190505b5060208601526040805160028082526060820190925290816020016020820280368337505050604086810191909152805160028082526060820183529091602083019080368337505050606086810191909152604080516002808252928101825291906020830190803683375050506080860152604080516002808252606082018352909160208301908036833750505060a086015260005b865181101561069757868181518110610340576103406128cf565b6020026020010151600001516001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610389573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103ad9190612933565b8482815181106103bf576103bf6128cf565b602002602001019060ff16908160ff16815250506000856001600160a01b031663aa9a09128984815181106103f6576103f66128cf565b6020026020010151604001518a8581518110610414576104146128cf565b602002602001015160200151888681518110610432576104326128cf565b6020026020010151600a6104469190612a52565b6040516001600160e01b031960e086901b168152600481019390935260248301919091526044820152606401602060405180830381865afa15801561048f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104b39190612a61565b90506104bf8184612a7a565b9250836000815181106104d4576104d46128cf565b602002602001015160e001516001600160a01b03168883815181106104fb576104fb6128cf565b6020026020010151600001516001600160a01b031603610563578184600081518110610529576105296128cf565b60200260200101516000018181525050808460008151811061054d5761054d6128cf565b6020026020010151604001818152505050610685565b83600181518110610576576105766128cf565b602002602001015160e001516001600160a01b031688838151811061059d5761059d6128cf565b6020026020010151600001516001600160a01b0316036105ef5781846001815181106105cb576105cb6128cf565b60200260200101516000018181525050808460018151811061054d5761054d6128cf565b878281518110610601576106016128cf565b60200260200101516000015187600001518381518110610623576106236128cf565b60200260200101906001600160a01b031690816001600160a01b031681525050878281518110610655576106556128cf565b60200260200101516020015187602001518381518110610677576106776128cf565b602002602001018181525050505b8061068f81612a8d565b915050610325565b506106a2888861201c565b836000815181106106b5576106b56128cf565b6020026020010151608001846001815181106106d3576106d36128cf565b602090810291909101015160800191909152526040516384cc315b60e01b81526001600160a01b038516906384cc315b90610712908b906004016128e5565b602060405180830381865afa15801561072f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107539190612a61565b82600081518110610766576107666128cf565b60200260200101516080015161077c9190612aa6565b8260008151811061078f5761078f6128cf565b60200260200101516060018181525050816001815181106107b2576107b26128cf565b602002602001015160e001516001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156107fb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061081f9190612933565b61082a90600a612a52565b8260018151811061083d5761083d6128cf565b6020026020010151608001516108539190612aa6565b82600081518110610866576108666128cf565b60200260200101516060015161087c9190612a7a565b8260018151811061088f5761088f6128cf565b60200260200101516060018181525050836001600160a01b031663aa9a091282846000815181106108c2576108c26128cf565b602002602001015160600151856001815181106108e1576108e16128cf565b6020026020010151606001516040518463ffffffff1660e01b815260040161091c939291909283526020830191909152604082015260600190565b602060405180830381865afa158015610939573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095d9190612a61565b8560a00151600081518110610974576109746128cf565b6020026020010181815250508460a00151600081518110610997576109976128cf565b6020026020010151816109aa9190612abd565b8560a001516001815181106109c1576109c16128cf565b602002602001018181525050816000815181106109e0576109e06128cf565b6020026020010151604001518560a00151600081518110610a0357610a036128cf565b6020026020010151148015610a53575081600181518110610a2657610a266128cf565b6020026020010151604001518560a00151600181518110610a4957610a496128cf565b6020026020010151145b8015610ac2575081600081518110610a6d57610a6d6128cf565b60200260200101516060015160001480610ac2575081600181518110610a9557610a956128cf565b60200260200101516060015182600081518110610ab457610ab46128cf565b602002602001015160600151145b15610bf45760608086526020860152855182518390600090610ae657610ae66128cf565b60200260200101516000015110610afe576000610b3b565b8582600081518110610b1257610b126128cf565b60200260200101516000015181518110610b2e57610b2e6128cf565b6020026020010151602001515b8560800151600081518110610b5257610b526128cf565b602002602001018181525050855182600181518110610b7357610b736128cf565b60200260200101516000015110610b8b576000610bc8565b8582600181518110610b9f57610b9f6128cf565b60200260200101516000015181518110610bbb57610bbb6128cf565b6020026020010151602001515b8560800151600181518110610bdf57610bdf6128cf565b60200260200101818152505050505050611429565b60005b6002811015611088578651838281518110610c1457610c146128cf565b602002602001015160000151108015610c665750828181518110610c3a57610c3a6128cf565b6020026020010151604001518660a001518281518110610c5c57610c5c6128cf565b6020026020010151105b1561107657846001600160a01b031663aa9a09128760a001518381518110610c9057610c906128cf565b6020026020010151858481518110610caa57610caa6128cf565b602002602001015160400151610cc09190612abd565b86868581518110610cd357610cd36128cf565b60200260200101516000015181518110610cef57610cef6128cf565b6020026020010151600a610d039190612a52565b8a878681518110610d1657610d166128cf565b60200260200101516000015181518110610d3257610d326128cf565b6020026020010151604001516040518463ffffffff1660e01b8152600401610d6d939291909283526020830191909152604082015260600190565b602060405180830381865afa158015610d8a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dae9190612a61565b838281518110610dc057610dc06128cf565b602002602001015160a001818152505086838281518110610de357610de36128cf565b60200260200101516000015181518110610dff57610dff6128cf565b6020026020010151600001518660000151848381518110610e2257610e226128cf565b60200260200101516000015181518110610e3e57610e3e6128cf565b60200260200101906001600160a01b031690816001600160a01b031681525050828181518110610e7057610e706128cf565b602002602001015160a001518660200151848381518110610e9357610e936128cf565b60200260200101516000015181518110610eaf57610eaf6128cf565b602090810291909101015282610ec6826001612abd565b81518110610ed657610ed66128cf565b602002602001015160e001518660400151600081518110610ef957610ef96128cf565b60200260200101906001600160a01b031690816001600160a01b031681525050620f42408660600151600081518110610f3457610f346128cf565b602002602001018181525050828181518110610f5257610f526128cf565b602002602001015160a0015187848381518110610f7157610f716128cf565b60200260200101516000015181518110610f8d57610f8d6128cf565b602002602001015160200151610fa39190612abd565b86608001518281518110610fb957610fb96128cf565b6020908102919091010152865183610fd2836001612abd565b81518110610fe257610fe26128cf565b60200260200101516000015110610ffa576000611040565b8683611007836001612abd565b81518110611017576110176128cf565b60200260200101516000015181518110611033576110336128cf565b6020026020010151602001515b6080870151611050836001612abd565b81518110611060576110606128cf565b6020026020010181815250505050505050611429565b8061108081612a8d565b915050610bf7565b508160008151811061109c5761109c6128cf565b602002602001015160e0015185604001516000815181106110bf576110bf6128cf565b60200260200101906001600160a01b031690816001600160a01b031681525050816001815181106110f2576110f26128cf565b602002602001015160e001518560400151600181518110611115576111156128cf565b60200260200101906001600160a01b031690816001600160a01b031681525050836001600160a01b031663aa9a091283600081518110611157576111576128cf565b6020026020010151604001518760a0015160008151811061117a5761117a6128cf565b602002602001015161118c9190612abd565b620f4240856001815181106111a3576111a36128cf565b602002602001015160400151866000815181106111c2576111c26128cf565b6020026020010151604001516111d89190612a7a565b8960a001516001815181106111ef576111ef6128cf565b60200260200101518a60a0015160008151811061120e5761120e6128cf565b60200260200101516112209190612a7a565b61122a9190612abd565b6040516001600160e01b031960e086901b168152600481019390935260248301919091526044820152606401602060405180830381865afa158015611273573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112979190612a61565b85606001516000815181106112ae576112ae6128cf565b60200260200101818152505084606001516000815181106112d1576112d16128cf565b6020026020010151620f42406112e79190612abd565b85606001516001815181106112fe576112fe6128cf565b60200260200101818152505085518260008151811061131f5761131f6128cf565b60200260200101516000015110611337576000611374565b858260008151811061134b5761134b6128cf565b60200260200101516000015181518110611367576113676128cf565b6020026020010151602001515b856080015160008151811061138b5761138b6128cf565b6020026020010181815250508551826001815181106113ac576113ac6128cf565b602002602001015160000151106113c4576000611401565b85826001815181106113d8576113d86128cf565b602002602001015160000151815181106113f4576113f46128cf565b6020026020010151602001515b8560800151600181518110611418576114186128cf565b602002602001018181525050505050505b9392505050565b6114386123d9565b815160021461147c5760405162461bcd60e51b815260206004820152600b60248201526a213d203220746f6b656e7360a81b60448201526064015b60405180910390fd5b604080516002808252606082018352309260009291906020830190803683375050604080516002808252606082019092529293506000929150602082015b6114c261240f565b8152602001906001900390816114ba57505060405163ca4f280360e01b81529091506000906001600160a01b0385169063ca4f280390611506908b906004016128e5565b6040805180830381865afa158015611522573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061154691906128f9565b83600081518110611559576115596128cf565b602002602001015160e00184600181518110611577576115776128cf565b60209081029190910101516001600160a01b0392831660e09091015291169052855186906000906115aa576115aa6128cf565b6020026020010151600001516001600160a01b0316826000815181106115d2576115d26128cf565b602002602001015160e001516001600160a01b0316148015611641575085600181518110611602576116026128cf565b6020026020010151600001516001600160a01b03168260018151811061162a5761162a6128cf565b602002602001015160e001516001600160a01b0316145b6116845760405162461bcd60e51b8152602060048201526014602482015273496e76616c696420696e70757420746f6b656e7360601b6044820152606401611473565b6040805160018082528183019092529060208083019080368337505050855260408051600180825281830190925290602080830190803683370190505060208601526040805160018082528183019092529081602001602082028036833750505060408681019190915280516001808252818301909252906020808301908036833750505060608681019190915260408051600280825292810182529190602083019080368337505050608086015260408051600280825260608201835290916020830190803683370190505060a0860152604051630693132f60e51b8152600481018a90526001600160a01b0385169063d26265e0906024016040805180830381865afa15801561179a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117be9190612ad0565b836000815181106117d1576117d16128cf565b6020026020010151602001846001815181106117ef576117ef6128cf565b60209081029190910181015101919091525260005b60028110156119d55786818151811061181f5761181f6128cf565b6020026020010151600001516001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015611868573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061188c9190612933565b84828151811061189e5761189e6128cf565b602002602001019060ff16908160ff16815250506000856001600160a01b031663aa9a09128984815181106118d5576118d56128cf565b6020026020010151602001518685815181106118f3576118f36128cf565b602002602001015160200151888681518110611911576119116128cf565b6020026020010151600a6119259190612a52565b6040516001600160e01b031960e086901b168152600481019390935260248301919091526044820152606401602060405180830381865afa15801561196e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119929190612a61565b905061199e8184612a7a565b9250808483815181106119b3576119b36128cf565b60209081029190910101516040015250806119cd81612a8d565b915050611804565b506119e0888861201c565b836000815181106119f3576119f36128cf565b602002602001015160800184600181518110611a1157611a116128cf565b602090810291909101015160800191909152526040516384cc315b60e01b81526001600160a01b038516906384cc315b90611a50908b906004016128e5565b602060405180830381865afa158015611a6d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a919190612a61565b82600081518110611aa457611aa46128cf565b602002602001015160800151611aba9190612aa6565b82600081518110611acd57611acd6128cf565b6020026020010151606001818152505082600181518110611af057611af06128cf565b6020026020010151600a611b049190612a52565b82600181518110611b1757611b176128cf565b602002602001015160800151611b2d9190612aa6565b82600081518110611b4057611b406128cf565b602002602001015160600151611b569190612a7a565b82600181518110611b6957611b696128cf565b60200260200101516060018181525050836001600160a01b031663aa9a09128284600081518110611b9c57611b9c6128cf565b60200260200101516060015185600181518110611bbb57611bbb6128cf565b6020026020010151606001516040518463ffffffff1660e01b8152600401611bf6939291909283526020830191909152604082015260600190565b602060405180830381865afa158015611c13573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c379190612a61565b8560a00151600081518110611c4e57611c4e6128cf565b6020026020010181815250508460a00151600081518110611c7157611c716128cf565b602002602001015181611c849190612abd565b8560a00151600181518110611c9b57611c9b6128cf565b60200260200101818152505060005b600281101561200f57828181518110611cc557611cc56128cf565b6020026020010151604001518660a001518281518110611ce757611ce76128cf565b60200260200101511015611ffd57846001600160a01b031663aa9a09128760a001518381518110611d1a57611d1a6128cf565b6020026020010151858481518110611d3457611d346128cf565b602002602001015160400151611d4a9190612abd565b868481518110611d5c57611d5c6128cf565b6020026020010151600a611d709190612a52565b8a8581518110611d8257611d826128cf565b6020026020010151602001516040518463ffffffff1660e01b8152600401611dbd939291909283526020830191909152604082015260600190565b602060405180830381865afa158015611dda573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611dfe9190612a61565b838281518110611e1057611e106128cf565b602002602001015160a0018181525050868181518110611e3257611e326128cf565b6020026020010151600001518660000151600081518110611e5557611e556128cf565b60200260200101906001600160a01b031690816001600160a01b031681525050828181518110611e8757611e876128cf565b602002602001015160a001518660200151600081518110611eaa57611eaa6128cf565b602090810291909101015282611ec1826001612abd565b81518110611ed157611ed16128cf565b602002602001015160e001518660400151600081518110611ef457611ef46128cf565b60200260200101906001600160a01b031690816001600160a01b031681525050620f42408660600151600081518110611f2f57611f2f6128cf565b602002602001018181525050828181518110611f4d57611f4d6128cf565b602002602001015160a00151838281518110611f6b57611f6b6128cf565b602002602001015160200151611f819190612abd565b86608001518281518110611f9757611f976128cf565b602090810291909101015282611fae826001612abd565b81518110611fbe57611fbe6128cf565b6020026020010151602001518660800151826001611fdc9190612abd565b81518110611fec57611fec6128cf565b60200260200101818152505061200f565b8061200781612a8d565b915050611caa565b5050505050949350505050565b60405163d79357fb60e01b81526000908190309082908190839063d79357fb9061204a908a906004016128e5565b6040805180830381865afa158015612066573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061208a9190612ad0565b9092509050600061209c83600a612af4565b905060006120ab83600a612af4565b90506000856001600160a01b0316635730ba088b6040518263ffffffff1660e01b81526004016120db91906128e5565b602060405180830381865afa1580156120f8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061211c9190612b00565b90506000866001600160a01b031663986cfba38b600081518110612142576121426128cf565b60200260200101516040518263ffffffff1660e01b815260040161216f919060029190910b815260200190565b602060405180830381865afa15801561218c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121b09190612b00565b90506000876001600160a01b031663986cfba38c6001815181106121d6576121d66128cf565b60200260200101516040518263ffffffff1660e01b8152600401612203919060029190910b815260200190565b602060405180830381865afa158015612220573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906122449190612b00565b905060006001600160a01b038916636098fd4a8585856122668b6103e8612aa6565b6122728b6103e8612aa6565b6040516001600160e01b031960e088901b1681526001600160a01b03958616600482015293851660248501529390911660448301526064820152608481019190915260a401602060405180830381865afa1580156122d4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906122f89190612b1d565b60405163c72e160b60e01b81526001600160a01b038681166004830152858116602483015284811660448301526001600160801b0383166064830152919250908a169063c72e160b906084016040805180830381865afa158015612360573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123849190612ad0565b909b5099506000858711612398578561239a565b865b90506123a68782612b46565b6123b0908d612aa6565b9b506123bc8682612b46565b6123c6908c612aa6565b9a50505050505050505050509250929050565b6040518060c001604052806060815260200160608152602001606081526020016060815260200160608152602001606081525090565b6040518061010001604052806000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160006001600160a01b031681525090565b6001600160a01b038116811461247257600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b604051606081016001600160401b03811182821017156124ad576124ad612475565b60405290565b604080519081016001600160401b03811182821017156124ad576124ad612475565b604051601f8201601f191681016001600160401b03811182821017156124fd576124fd612475565b604052919050565b60006001600160401b0382111561251e5761251e612475565b5060051b60200190565b600082601f83011261253957600080fd5b8135602061254e61254983612505565b6124d5565b82815260059290921b8401810191818101908684111561256d57600080fd5b8286015b848110156125985780358060020b811461258b5760008081fd5b8352918301918301612571565b509695505050505050565b600080600060608085870312156125b957600080fd5b84356125c48161245d565b93506020858101356001600160401b03808211156125e157600080fd5b6125ed89838a01612528565b955060409150818801358181111561260457600080fd5b88019050601f8101891361261757600080fd5b803561262561254982612505565b8181529085028201840190848101908b83111561264157600080fd5b928501925b828410156126925786848d03121561265e5760008081fd5b61266661248b565b84356126718161245d565b81528487013587820152858501358682015282529286019290850190612646565b809750505050505050509250925092565b600081518084526020808501945080840160005b838110156126dc5781516001600160a01b0316875295820195908201906001016126b7565b509495945050505050565b600081518084526020808501945080840160005b838110156126dc578151875295820195908201906001016126fb565b602081526000825160c0602084015261273360e08401826126a3565b90506020840151601f198085840301604086015261275183836126e7565b9250604086015191508085840301606086015261276e83836126a3565b9250606086015191508085840301608086015261278b83836126e7565b925060808601519150808584030160a08601526127a883836126e7565b925060a08601519150808584030160c0860152506127c682826126e7565b95945050505050565b600080600080608085870312156127e557600080fd5b843593506020808601356127f88161245d565b93506040868101356001600160401b038082111561281557600080fd5b6128218a838b01612528565b9550606089013591508082111561283757600080fd5b508701601f8101891361284957600080fd5b803561285761254982612505565b81815260069190911b8201840190848101908b83111561287657600080fd5b928501925b828410156128bf5784848d0312156128935760008081fd5b61289b6124b3565b84356128a68161245d565b815284870135878201528252928401929085019061287b565b989b979a50959850505050505050565b634e487b7160e01b600052603260045260246000fd5b6001600160a01b0391909116815260200190565b6000806040838503121561290c57600080fd5b82516129178161245d565b60208401519092506129288161245d565b809150509250929050565b60006020828403121561294557600080fd5b815160ff8116811461142957600080fd5b634e487b7160e01b600052601160045260246000fd5b600181815b808511156129a757816000190482111561298d5761298d612956565b8085161561299a57918102915b93841c9390800290612971565b509250929050565b6000826129be57506001612a4c565b816129cb57506000612a4c565b81600181146129e157600281146129eb57612a07565b6001915050612a4c565b60ff8411156129fc576129fc612956565b50506001821b612a4c565b5060208310610133831016604e8410600b8410161715612a2a575081810a612a4c565b612a34838361296c565b8060001904821115612a4857612a48612956565b0290505b92915050565b600061142960ff8416836129af565b600060208284031215612a7357600080fd5b5051919050565b80820180821115612a4c57612a4c612956565b600060018201612a9f57612a9f612956565b5060010190565b8082028115828204841417612a4c57612a4c612956565b81810381811115612a4c57612a4c612956565b60008060408385031215612ae357600080fd5b505080516020909101519092909150565b600061142983836129af565b600060208284031215612b1257600080fd5b81516114298161245d565b600060208284031215612b2f57600080fd5b81516001600160801b038116811461142957600080fd5b600082612b6357634e487b7160e01b600052601260045260246000fd5b50049056fea26469706673582212205c3e31220398e25b7e31f93d93385ddb2cf53ba545cf55cc0fe19d7d68bc791a64736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100365760003560e01c80638866c09f1461003b578063b298ad6e14610064575b600080fd5b61004e6100493660046125a3565b610077565b60405161005b9190612717565b60405180910390f35b61004e6100723660046127cf565b611430565b61007f6123d9565b815130906000906001600160401b0381111561009d5761009d612475565b6040519080825280602002602001820160405280156100c6578160200160208202803683370190505b506040805160028082526060820190925291925060009190816020015b6100eb61240f565b8152602001906001900390816100e35790505090506000855182600081518110610117576101176128cf565b6020026020010151600001818152505085518260018151811061013c5761013c6128cf565b60209081029190910101515260405163ca4f280360e01b81526001600160a01b0385169063ca4f280390610174908b906004016128e5565b6040805180830381865afa158015610190573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101b491906128f9565b836000815181106101c7576101c76128cf565b602002602001015160e001846001815181106101e5576101e56128cf565b60209081029190910101516001600160a01b0392831660e0909101529116905285516001600160401b0381111561021e5761021e612475565b604051908082528060200260200182016040528015610247578160200160208202803683370190505b50855285516001600160401b0381111561026357610263612475565b60405190808252806020026020018201604052801561028c578160200160208202803683370190505b5060208601526040805160028082526060820190925290816020016020820280368337505050604086810191909152805160028082526060820183529091602083019080368337505050606086810191909152604080516002808252928101825291906020830190803683375050506080860152604080516002808252606082018352909160208301908036833750505060a086015260005b865181101561069757868181518110610340576103406128cf565b6020026020010151600001516001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610389573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103ad9190612933565b8482815181106103bf576103bf6128cf565b602002602001019060ff16908160ff16815250506000856001600160a01b031663aa9a09128984815181106103f6576103f66128cf565b6020026020010151604001518a8581518110610414576104146128cf565b602002602001015160200151888681518110610432576104326128cf565b6020026020010151600a6104469190612a52565b6040516001600160e01b031960e086901b168152600481019390935260248301919091526044820152606401602060405180830381865afa15801561048f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104b39190612a61565b90506104bf8184612a7a565b9250836000815181106104d4576104d46128cf565b602002602001015160e001516001600160a01b03168883815181106104fb576104fb6128cf565b6020026020010151600001516001600160a01b031603610563578184600081518110610529576105296128cf565b60200260200101516000018181525050808460008151811061054d5761054d6128cf565b6020026020010151604001818152505050610685565b83600181518110610576576105766128cf565b602002602001015160e001516001600160a01b031688838151811061059d5761059d6128cf565b6020026020010151600001516001600160a01b0316036105ef5781846001815181106105cb576105cb6128cf565b60200260200101516000018181525050808460018151811061054d5761054d6128cf565b878281518110610601576106016128cf565b60200260200101516000015187600001518381518110610623576106236128cf565b60200260200101906001600160a01b031690816001600160a01b031681525050878281518110610655576106556128cf565b60200260200101516020015187602001518381518110610677576106776128cf565b602002602001018181525050505b8061068f81612a8d565b915050610325565b506106a2888861201c565b836000815181106106b5576106b56128cf565b6020026020010151608001846001815181106106d3576106d36128cf565b602090810291909101015160800191909152526040516384cc315b60e01b81526001600160a01b038516906384cc315b90610712908b906004016128e5565b602060405180830381865afa15801561072f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107539190612a61565b82600081518110610766576107666128cf565b60200260200101516080015161077c9190612aa6565b8260008151811061078f5761078f6128cf565b60200260200101516060018181525050816001815181106107b2576107b26128cf565b602002602001015160e001516001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156107fb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061081f9190612933565b61082a90600a612a52565b8260018151811061083d5761083d6128cf565b6020026020010151608001516108539190612aa6565b82600081518110610866576108666128cf565b60200260200101516060015161087c9190612a7a565b8260018151811061088f5761088f6128cf565b60200260200101516060018181525050836001600160a01b031663aa9a091282846000815181106108c2576108c26128cf565b602002602001015160600151856001815181106108e1576108e16128cf565b6020026020010151606001516040518463ffffffff1660e01b815260040161091c939291909283526020830191909152604082015260600190565b602060405180830381865afa158015610939573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095d9190612a61565b8560a00151600081518110610974576109746128cf565b6020026020010181815250508460a00151600081518110610997576109976128cf565b6020026020010151816109aa9190612abd565b8560a001516001815181106109c1576109c16128cf565b602002602001018181525050816000815181106109e0576109e06128cf565b6020026020010151604001518560a00151600081518110610a0357610a036128cf565b6020026020010151148015610a53575081600181518110610a2657610a266128cf565b6020026020010151604001518560a00151600181518110610a4957610a496128cf565b6020026020010151145b8015610ac2575081600081518110610a6d57610a6d6128cf565b60200260200101516060015160001480610ac2575081600181518110610a9557610a956128cf565b60200260200101516060015182600081518110610ab457610ab46128cf565b602002602001015160600151145b15610bf45760608086526020860152855182518390600090610ae657610ae66128cf565b60200260200101516000015110610afe576000610b3b565b8582600081518110610b1257610b126128cf565b60200260200101516000015181518110610b2e57610b2e6128cf565b6020026020010151602001515b8560800151600081518110610b5257610b526128cf565b602002602001018181525050855182600181518110610b7357610b736128cf565b60200260200101516000015110610b8b576000610bc8565b8582600181518110610b9f57610b9f6128cf565b60200260200101516000015181518110610bbb57610bbb6128cf565b6020026020010151602001515b8560800151600181518110610bdf57610bdf6128cf565b60200260200101818152505050505050611429565b60005b6002811015611088578651838281518110610c1457610c146128cf565b602002602001015160000151108015610c665750828181518110610c3a57610c3a6128cf565b6020026020010151604001518660a001518281518110610c5c57610c5c6128cf565b6020026020010151105b1561107657846001600160a01b031663aa9a09128760a001518381518110610c9057610c906128cf565b6020026020010151858481518110610caa57610caa6128cf565b602002602001015160400151610cc09190612abd565b86868581518110610cd357610cd36128cf565b60200260200101516000015181518110610cef57610cef6128cf565b6020026020010151600a610d039190612a52565b8a878681518110610d1657610d166128cf565b60200260200101516000015181518110610d3257610d326128cf565b6020026020010151604001516040518463ffffffff1660e01b8152600401610d6d939291909283526020830191909152604082015260600190565b602060405180830381865afa158015610d8a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dae9190612a61565b838281518110610dc057610dc06128cf565b602002602001015160a001818152505086838281518110610de357610de36128cf565b60200260200101516000015181518110610dff57610dff6128cf565b6020026020010151600001518660000151848381518110610e2257610e226128cf565b60200260200101516000015181518110610e3e57610e3e6128cf565b60200260200101906001600160a01b031690816001600160a01b031681525050828181518110610e7057610e706128cf565b602002602001015160a001518660200151848381518110610e9357610e936128cf565b60200260200101516000015181518110610eaf57610eaf6128cf565b602090810291909101015282610ec6826001612abd565b81518110610ed657610ed66128cf565b602002602001015160e001518660400151600081518110610ef957610ef96128cf565b60200260200101906001600160a01b031690816001600160a01b031681525050620f42408660600151600081518110610f3457610f346128cf565b602002602001018181525050828181518110610f5257610f526128cf565b602002602001015160a0015187848381518110610f7157610f716128cf565b60200260200101516000015181518110610f8d57610f8d6128cf565b602002602001015160200151610fa39190612abd565b86608001518281518110610fb957610fb96128cf565b6020908102919091010152865183610fd2836001612abd565b81518110610fe257610fe26128cf565b60200260200101516000015110610ffa576000611040565b8683611007836001612abd565b81518110611017576110176128cf565b60200260200101516000015181518110611033576110336128cf565b6020026020010151602001515b6080870151611050836001612abd565b81518110611060576110606128cf565b6020026020010181815250505050505050611429565b8061108081612a8d565b915050610bf7565b508160008151811061109c5761109c6128cf565b602002602001015160e0015185604001516000815181106110bf576110bf6128cf565b60200260200101906001600160a01b031690816001600160a01b031681525050816001815181106110f2576110f26128cf565b602002602001015160e001518560400151600181518110611115576111156128cf565b60200260200101906001600160a01b031690816001600160a01b031681525050836001600160a01b031663aa9a091283600081518110611157576111576128cf565b6020026020010151604001518760a0015160008151811061117a5761117a6128cf565b602002602001015161118c9190612abd565b620f4240856001815181106111a3576111a36128cf565b602002602001015160400151866000815181106111c2576111c26128cf565b6020026020010151604001516111d89190612a7a565b8960a001516001815181106111ef576111ef6128cf565b60200260200101518a60a0015160008151811061120e5761120e6128cf565b60200260200101516112209190612a7a565b61122a9190612abd565b6040516001600160e01b031960e086901b168152600481019390935260248301919091526044820152606401602060405180830381865afa158015611273573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112979190612a61565b85606001516000815181106112ae576112ae6128cf565b60200260200101818152505084606001516000815181106112d1576112d16128cf565b6020026020010151620f42406112e79190612abd565b85606001516001815181106112fe576112fe6128cf565b60200260200101818152505085518260008151811061131f5761131f6128cf565b60200260200101516000015110611337576000611374565b858260008151811061134b5761134b6128cf565b60200260200101516000015181518110611367576113676128cf565b6020026020010151602001515b856080015160008151811061138b5761138b6128cf565b6020026020010181815250508551826001815181106113ac576113ac6128cf565b602002602001015160000151106113c4576000611401565b85826001815181106113d8576113d86128cf565b602002602001015160000151815181106113f4576113f46128cf565b6020026020010151602001515b8560800151600181518110611418576114186128cf565b602002602001018181525050505050505b9392505050565b6114386123d9565b815160021461147c5760405162461bcd60e51b815260206004820152600b60248201526a213d203220746f6b656e7360a81b60448201526064015b60405180910390fd5b604080516002808252606082018352309260009291906020830190803683375050604080516002808252606082019092529293506000929150602082015b6114c261240f565b8152602001906001900390816114ba57505060405163ca4f280360e01b81529091506000906001600160a01b0385169063ca4f280390611506908b906004016128e5565b6040805180830381865afa158015611522573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061154691906128f9565b83600081518110611559576115596128cf565b602002602001015160e00184600181518110611577576115776128cf565b60209081029190910101516001600160a01b0392831660e09091015291169052855186906000906115aa576115aa6128cf565b6020026020010151600001516001600160a01b0316826000815181106115d2576115d26128cf565b602002602001015160e001516001600160a01b0316148015611641575085600181518110611602576116026128cf565b6020026020010151600001516001600160a01b03168260018151811061162a5761162a6128cf565b602002602001015160e001516001600160a01b0316145b6116845760405162461bcd60e51b8152602060048201526014602482015273496e76616c696420696e70757420746f6b656e7360601b6044820152606401611473565b6040805160018082528183019092529060208083019080368337505050855260408051600180825281830190925290602080830190803683370190505060208601526040805160018082528183019092529081602001602082028036833750505060408681019190915280516001808252818301909252906020808301908036833750505060608681019190915260408051600280825292810182529190602083019080368337505050608086015260408051600280825260608201835290916020830190803683370190505060a0860152604051630693132f60e51b8152600481018a90526001600160a01b0385169063d26265e0906024016040805180830381865afa15801561179a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117be9190612ad0565b836000815181106117d1576117d16128cf565b6020026020010151602001846001815181106117ef576117ef6128cf565b60209081029190910181015101919091525260005b60028110156119d55786818151811061181f5761181f6128cf565b6020026020010151600001516001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015611868573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061188c9190612933565b84828151811061189e5761189e6128cf565b602002602001019060ff16908160ff16815250506000856001600160a01b031663aa9a09128984815181106118d5576118d56128cf565b6020026020010151602001518685815181106118f3576118f36128cf565b602002602001015160200151888681518110611911576119116128cf565b6020026020010151600a6119259190612a52565b6040516001600160e01b031960e086901b168152600481019390935260248301919091526044820152606401602060405180830381865afa15801561196e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119929190612a61565b905061199e8184612a7a565b9250808483815181106119b3576119b36128cf565b60209081029190910101516040015250806119cd81612a8d565b915050611804565b506119e0888861201c565b836000815181106119f3576119f36128cf565b602002602001015160800184600181518110611a1157611a116128cf565b602090810291909101015160800191909152526040516384cc315b60e01b81526001600160a01b038516906384cc315b90611a50908b906004016128e5565b602060405180830381865afa158015611a6d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a919190612a61565b82600081518110611aa457611aa46128cf565b602002602001015160800151611aba9190612aa6565b82600081518110611acd57611acd6128cf565b6020026020010151606001818152505082600181518110611af057611af06128cf565b6020026020010151600a611b049190612a52565b82600181518110611b1757611b176128cf565b602002602001015160800151611b2d9190612aa6565b82600081518110611b4057611b406128cf565b602002602001015160600151611b569190612a7a565b82600181518110611b6957611b696128cf565b60200260200101516060018181525050836001600160a01b031663aa9a09128284600081518110611b9c57611b9c6128cf565b60200260200101516060015185600181518110611bbb57611bbb6128cf565b6020026020010151606001516040518463ffffffff1660e01b8152600401611bf6939291909283526020830191909152604082015260600190565b602060405180830381865afa158015611c13573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c379190612a61565b8560a00151600081518110611c4e57611c4e6128cf565b6020026020010181815250508460a00151600081518110611c7157611c716128cf565b602002602001015181611c849190612abd565b8560a00151600181518110611c9b57611c9b6128cf565b60200260200101818152505060005b600281101561200f57828181518110611cc557611cc56128cf565b6020026020010151604001518660a001518281518110611ce757611ce76128cf565b60200260200101511015611ffd57846001600160a01b031663aa9a09128760a001518381518110611d1a57611d1a6128cf565b6020026020010151858481518110611d3457611d346128cf565b602002602001015160400151611d4a9190612abd565b868481518110611d5c57611d5c6128cf565b6020026020010151600a611d709190612a52565b8a8581518110611d8257611d826128cf565b6020026020010151602001516040518463ffffffff1660e01b8152600401611dbd939291909283526020830191909152604082015260600190565b602060405180830381865afa158015611dda573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611dfe9190612a61565b838281518110611e1057611e106128cf565b602002602001015160a0018181525050868181518110611e3257611e326128cf565b6020026020010151600001518660000151600081518110611e5557611e556128cf565b60200260200101906001600160a01b031690816001600160a01b031681525050828181518110611e8757611e876128cf565b602002602001015160a001518660200151600081518110611eaa57611eaa6128cf565b602090810291909101015282611ec1826001612abd565b81518110611ed157611ed16128cf565b602002602001015160e001518660400151600081518110611ef457611ef46128cf565b60200260200101906001600160a01b031690816001600160a01b031681525050620f42408660600151600081518110611f2f57611f2f6128cf565b602002602001018181525050828181518110611f4d57611f4d6128cf565b602002602001015160a00151838281518110611f6b57611f6b6128cf565b602002602001015160200151611f819190612abd565b86608001518281518110611f9757611f976128cf565b602090810291909101015282611fae826001612abd565b81518110611fbe57611fbe6128cf565b6020026020010151602001518660800151826001611fdc9190612abd565b81518110611fec57611fec6128cf565b60200260200101818152505061200f565b8061200781612a8d565b915050611caa565b5050505050949350505050565b60405163d79357fb60e01b81526000908190309082908190839063d79357fb9061204a908a906004016128e5565b6040805180830381865afa158015612066573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061208a9190612ad0565b9092509050600061209c83600a612af4565b905060006120ab83600a612af4565b90506000856001600160a01b0316635730ba088b6040518263ffffffff1660e01b81526004016120db91906128e5565b602060405180830381865afa1580156120f8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061211c9190612b00565b90506000866001600160a01b031663986cfba38b600081518110612142576121426128cf565b60200260200101516040518263ffffffff1660e01b815260040161216f919060029190910b815260200190565b602060405180830381865afa15801561218c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121b09190612b00565b90506000876001600160a01b031663986cfba38c6001815181106121d6576121d66128cf565b60200260200101516040518263ffffffff1660e01b8152600401612203919060029190910b815260200190565b602060405180830381865afa158015612220573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906122449190612b00565b905060006001600160a01b038916636098fd4a8585856122668b6103e8612aa6565b6122728b6103e8612aa6565b6040516001600160e01b031960e088901b1681526001600160a01b03958616600482015293851660248501529390911660448301526064820152608481019190915260a401602060405180830381865afa1580156122d4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906122f89190612b1d565b60405163c72e160b60e01b81526001600160a01b038681166004830152858116602483015284811660448301526001600160801b0383166064830152919250908a169063c72e160b906084016040805180830381865afa158015612360573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123849190612ad0565b909b5099506000858711612398578561239a565b865b90506123a68782612b46565b6123b0908d612aa6565b9b506123bc8682612b46565b6123c6908c612aa6565b9a50505050505050505050509250929050565b6040518060c001604052806060815260200160608152602001606081526020016060815260200160608152602001606081525090565b6040518061010001604052806000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160006001600160a01b031681525090565b6001600160a01b038116811461247257600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b604051606081016001600160401b03811182821017156124ad576124ad612475565b60405290565b604080519081016001600160401b03811182821017156124ad576124ad612475565b604051601f8201601f191681016001600160401b03811182821017156124fd576124fd612475565b604052919050565b60006001600160401b0382111561251e5761251e612475565b5060051b60200190565b600082601f83011261253957600080fd5b8135602061254e61254983612505565b6124d5565b82815260059290921b8401810191818101908684111561256d57600080fd5b8286015b848110156125985780358060020b811461258b5760008081fd5b8352918301918301612571565b509695505050505050565b600080600060608085870312156125b957600080fd5b84356125c48161245d565b93506020858101356001600160401b03808211156125e157600080fd5b6125ed89838a01612528565b955060409150818801358181111561260457600080fd5b88019050601f8101891361261757600080fd5b803561262561254982612505565b8181529085028201840190848101908b83111561264157600080fd5b928501925b828410156126925786848d03121561265e5760008081fd5b61266661248b565b84356126718161245d565b81528487013587820152858501358682015282529286019290850190612646565b809750505050505050509250925092565b600081518084526020808501945080840160005b838110156126dc5781516001600160a01b0316875295820195908201906001016126b7565b509495945050505050565b600081518084526020808501945080840160005b838110156126dc578151875295820195908201906001016126fb565b602081526000825160c0602084015261273360e08401826126a3565b90506020840151601f198085840301604086015261275183836126e7565b9250604086015191508085840301606086015261276e83836126a3565b9250606086015191508085840301608086015261278b83836126e7565b925060808601519150808584030160a08601526127a883836126e7565b925060a08601519150808584030160c0860152506127c682826126e7565b95945050505050565b600080600080608085870312156127e557600080fd5b843593506020808601356127f88161245d565b93506040868101356001600160401b038082111561281557600080fd5b6128218a838b01612528565b9550606089013591508082111561283757600080fd5b508701601f8101891361284957600080fd5b803561285761254982612505565b81815260069190911b8201840190848101908b83111561287657600080fd5b928501925b828410156128bf5784848d0312156128935760008081fd5b61289b6124b3565b84356128a68161245d565b815284870135878201528252928401929085019061287b565b989b979a50959850505050505050565b634e487b7160e01b600052603260045260246000fd5b6001600160a01b0391909116815260200190565b6000806040838503121561290c57600080fd5b82516129178161245d565b60208401519092506129288161245d565b809150509250929050565b60006020828403121561294557600080fd5b815160ff8116811461142957600080fd5b634e487b7160e01b600052601160045260246000fd5b600181815b808511156129a757816000190482111561298d5761298d612956565b8085161561299a57918102915b93841c9390800290612971565b509250929050565b6000826129be57506001612a4c565b816129cb57506000612a4c565b81600181146129e157600281146129eb57612a07565b6001915050612a4c565b60ff8411156129fc576129fc612956565b50506001821b612a4c565b5060208310610133831016604e8410600b8410161715612a2a575081810a612a4c565b612a34838361296c565b8060001904821115612a4857612a48612956565b0290505b92915050565b600061142960ff8416836129af565b600060208284031215612a7357600080fd5b5051919050565b80820180821115612a4c57612a4c612956565b600060018201612a9f57612a9f612956565b5060010190565b8082028115828204841417612a4c57612a4c612956565b81810381811115612a4c57612a4c612956565b60008060408385031215612ae357600080fd5b505080516020909101519092909150565b600061142983836129af565b600060208284031215612b1257600080fd5b81516114298161245d565b600060208284031215612b2f57600080fd5b81516001600160801b038116811461142957600080fd5b600082612b6357634e487b7160e01b600052601260045260246000fd5b50049056fea26469706673582212205c3e31220398e25b7e31f93d93385ddb2cf53ba545cf55cc0fe19d7d68bc791a64736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}